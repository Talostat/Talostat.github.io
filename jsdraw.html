<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>canvas绘图</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        .canvas-container {
            position: relative;
            background-color: yellow;
            width: 1600px;
            height: 800px;
            background-repeat: no-repeat;
            background-size: contain;
            background-color: white;
            background-position: left top;
        }

        .canvas-container::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            background-size: cover;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        .canvas-layer {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
            z-index: 2;
        }
    </style>
</head>

<body>
    <input type="file" id="imageInput" accept="image/*" style="display: none;">
    <label><input type="checkbox" id="activeYellow"> Draw Yellow Line</label>
    <button id="swapLayersbtn">Switch Pen</button>
    <button id="cleanLinebtn">Clean Line</button>
    <input type="number" id="rulerInput" value=100>Ruler</input>
    <div class="canvas-container" id="canvasContainer">
        <canvas id="canvas1" class="canvas-layer" width="1600" height="800"></canvas>
        <canvas id="canvas2" class="canvas-layer" width="1600" height="800"></canvas>
    </div>

    <script type="text/javascript">
        document.addEventListener("contextmenu", function (event) {
            //event.preventDefault();
        });
        var isSwapped = false
        isMouseUp = false
        isDrawing = false
        isUpdateRuler = false
        isCleanLine = false
        lines = []
        mainLine = []
        lineColor = "blue"
        labelColor = "red"
        rect = canvas2.getBoundingClientRect()
        ruler = rulerInput.value
        ctx1 = canvas1.getContext("2d")
        ctx2 = canvas2.getContext("2d")
        ctx1.lineWidth = 4
        ctx1.lineCap = "butt"; // 设置线条末端样式为平头
        ctx1.lineJoin = "miter"; // 设置线条连接样式为尖角
        ctx1.font = "14px Arial"
        ctx2.lineWidth = 6;
        ctx2.lineCap = "butt"; // 设置线条末端样式为平头
        ctx2.lineJoin = "miter"; // 设置线条连接样式为尖角        
        ctx2.font = "20px Arial"


        function isCursorOnLine(mouseX, mouseY, x1, y1, x2, y2) {
            const distance = Math.abs((y2 - y1) * mouseX - (x2 - x1) * mouseY + x2 * y1 - y2 * x1) /
                Math.sqrt(Math.pow(y2 - y1, 2) + Math.pow(x2 - x1, 2));
            return distance < 5; // 設定觸發清除的距離閾值
        }


        function redrawCanvas(ctx1, canvas) {
            ctx1.clearRect(0, 0, canvas.width, canvas.height);
        }


        function switchLayer(event, toCanv = null) {
            var parent = canvas1.parentNode;
            if (toCanv == 1) {
                parent.insertBefore(canvas1, canvas2);
            } else if (toCanv == 2) {
                parent.insertBefore(canvas2, canvas1);
            } else if (toCanv == null) {
                if (isSwapped) {
                    parent.insertBefore(canvas1, canvas2);
                } else {
                    parent.insertBefore(canvas2, canvas1);
                }
                isSwapped = !isSwapped; // 切换状态
            }
        }


        function drawLines() {
            //draw current line
            line = lines[lines.length - 1]
            labelX = (line.start.x + line.end.x) / 2
            labelY = (line.start.y + line.end.y) / 2
            lineLength = calLength(line)
            label = String(lineLength)
            ctx1.beginPath()
            ctx1.moveTo(line.start.x, line.start.y)
            ctx1.lineTo(line.end.x, line.end.y)
            ctx1.strokeStyle = lineColor
            ctx1.stroke()
            ctx1.fillStyle = labelColor
            ctx1.fillText(label, labelX, labelY)
            //store current line attr when mouse up 
            if (isMouseUp) {
                attrlist = {
                    label: label,
                    labelX: labelX,
                    labelY: labelY,
                    labelColor: labelColor,
                    lineColor: lineColor,
                }
                for (var key in attrlist) {
                    line[key] = attrlist[key]
                }
            }

            // draw preious lines
            for (var i = 0; i < lines.length - 1; i++) {
                line = lines[i];
                // updateLabels
                if (isUpdateRuler) {
                    lineLength = calLength(line)
                    label = String(lineLength)
                    line['label'] = lineLength
                } else {
                    label = line.label
                }
                ctx1.beginPath();
                ctx1.moveTo(line.start.x, line.start.y);
                ctx1.lineTo(line.end.x, line.end.y);
                ctx1.strokeStyle = line.lineColor
                ctx1.stroke();
                ctx1.fillStyle = line.textColor;
                ctx1.fillText(label, line.labelX, line.labelY);
            }
        }


        function drawmainLine() {
            //draw current line
            labelX = (mainLine[0].start.x + mainLine[0].end.x) / 2
            labelY = (mainLine[0].start.y + mainLine[0].end.y) / 2
            label = String(ruler)
            ctx2.beginPath()
            ctx2.moveTo(mainLine[0].start.x, mainLine[0].start.y)
            ctx2.lineTo(mainLine[0].end.x, mainLine[0].end.y)
            ctx2.strokeStyle = "red"
            ctx2.stroke()
            ctx2.fillStyle = labelColor
            ctx2.fillText(label, labelX, labelY)
        }


        function calLength(line) {
            let stdx = mainLine[0].end.x - mainLine[0].start.x
            let stdy = mainLine[0].end.y - mainLine[0].start.y
            let stdistance = Math.sqrt(stdx * stdx + stdy * stdy)
            let dx = line.end.x - line.start.x
            let dy = line.end.y - line.start.y
            let distance = Math.sqrt(dx * dx + dy * dy)
            lineLength = (ruler * distance / stdistance).toFixed(0)
            return lineLength
        }


        function handleMouseMove(e) {
            const mouseX = e.offsetX;
            const mouseY = e.offsetY;

            // 判斷滑鼠是否在特定線段上
            for (var i = 0; i < lines.length; i++) {
                line = lines[i]
                let x1, y1, x2, y2;
                [x1, y1, x2, y2] = [line.start.x, line.start.y, line.end.x, line.end.y];
                if (isCursorOnLine(mouseX, mouseY, x1, y1, x2, y2)) {
                    lines.splice(i, 1);
                    break
                }
            }
        }

        // 激活清除子線
        cleanLinebtn.addEventListener("click", function (e) {
            isCleanLine = (isCleanLine == false) ? true : false
            console.log("Clean Line:" + isCleanLine)
            switchLayer(1);
            if (isCleanLine) {
                // remove drawLine Event
                canvas1.removeEventListener("mousedown", subLinesMouseDown);
                canvas1.removeEventListener("mousemove", subLinesMouseMove);
                canvas1.removeEventListener("mouseup", subLinesMouseUp);
                // add CleanLine Event
                canvas1.addEventListener("click", handleMouseMove);
            } else {
                // remove CleanLine Event
                canvas1.removeEventListener("click", handleMouseMove);

                // resume drawLine Event
                canvas1.addEventListener("mousedown", subLinesMouseDown);
                canvas1.addEventListener("mousemove", subLinesMouseMove);
                canvas1.addEventListener("mouseup", subLinesMouseUp);
            }
        });


        // 交换层级
        swapLayersbtn.addEventListener("click", function (event) {
            switchLayer(event);
        });

        // 更新標尺
        rulerInput.addEventListener("input", function () {
            isUpdateRuler = true
            ruler = rulerInput.value
            redrawCanvas(ctx2, canvas2)
            drawmainLine()
            redrawCanvas(ctx1, canvas1)
            drawLines()
            isUpdateRuler = false
        });

        // 手动画黄色直线
        activeYellow.addEventListener("change", function () {
            lineColor = activeYellow.checked ? "yellow" : "blue";
        });

        // 拖动图片加载为背景
        canvasContainer.addEventListener("dragover", function (e) {
            e.preventDefault();
        });
        canvasContainer.addEventListener("drop", function (e) {
            e.preventDefault();
            console.log("drop")
            var file = event.dataTransfer.files[0];
            if (file.type.startsWith('image/')) {
                var reader = new FileReader();
                reader.onload = function (event) {
                    var imageUrl = event.target.result;
                    canvasContainer.style.backgroundImage = 'url(' + imageUrl + ')';
                };
                reader.readAsDataURL(file);
            }
        });


        function subLinesMouseDown(e) {
            console.log("mousedown")
            isDrawing = true;
            var startPosition = { x: e.clientX, y: e.clientY - rect.top };
            lines.push({ start: startPosition, end: startPosition });
        }

        function subLinesMouseMove(e) {
            if (isDrawing) {
                console.log("mousemove")
                var currentPosition = { x: e.clientX, y: e.clientY - rect.top };
                lines[lines.length - 1].end = currentPosition;
                redrawCanvas(ctx1, canvas1);
                drawLines();
            }
        }

        function subLinesMouseUp(e) {
            if (isDrawing) {
                isMouseUp = true
                console.log("mouseup")
                isDrawing = false;
                var endPosition = { x: e.clientX, y: e.clientY - rect.top };
                lines[lines.length - 1].end = endPosition;
                redrawCanvas(ctx1, canvas1);
                drawLines();
                isMouseUp = false;
            }
        }

        function mainLinesMousedown(e) {
            console.log("mousedown")
            isDrawing = true;
            startPosition = { x: e.clientX, y: e.clientY - rect.top };
            mainLine[0] = { start: startPosition, end: startPosition };
        }
        function mainLinesMouseMove(e) {
            if (isDrawing) {
                console.log("mousemove")
                rect = canvas2.getBoundingClientRect();
                currentPosition = { x: e.clientX, y: e.clientY - rect.top };
                mainLine[0].end = currentPosition;
                redrawCanvas(ctx2, canvas2);
                drawmainLine();
            }
        }
        function mainLinesMouseUp(e) {
            if (isDrawing) {
                isMouseUp = true
                console.log("mouseup")
                isDrawing = false;
                endPosition = { x: e.clientX, y: e.clientY - rect.top };
                mainLine[0].end = endPosition;
                redrawCanvas(ctx2, canvas2);
                drawmainLine();
                if (lines.length != 0) {
                    redrawCanvas(ctx1, canvas1)
                    drawLines()
                }
                isMouseUp = false;
            }
        }

        // 畫子線
        canvas1.addEventListener("mousedown", subLinesMouseDown);
        canvas1.addEventListener("mousemove", subLinesMouseMove);
        canvas1.addEventListener("mouseup", subLinesMouseUp);
        canvas2.addEventListener("mousedown", mainLinesMousedown);
        canvas2.addEventListener("mousemove", mainLinesMouseMove);
        canvas2.addEventListener("mouseup", mainLinesMouseUp);


    </script>
</body>

</html>